import { createContext, useMemo, createElement, Fragment, useContext, useCallback } from 'react';

const conjunctions = [
  'for',
  'and',
  'nor',
  'but',
  'or',
  'yet',
  'so'
];

const articles = [
  'a',
  'an',
  'the'
];

const prepositions = [
  'aboard',
  'about',
  'above',
  'across',
  'after',
  'against',
  'along',
  'amid',
  'among',
  'anti',
  'around',
  'as',
  'at',
  'before',
  'behind',
  'below',
  'beneath',
  'beside',
  'besides',
  'between',
  'beyond',
  'but',
  'by',
  'concerning',
  'considering',
  'despite',
  'down',
  'during',
  'except',
  'excepting',
  'excluding',
  'following',
  'for',
  'from',
  'in',
  'inside',
  'into',
  'like',
  'minus',
  'near',
  'of',
  'off',
  'on',
  'onto',
  'opposite',
  'over',
  'past',
  'per',
  'plus',
  'regarding',
  'round',
  'save',
  'since',
  'than',
  'through',
  'to',
  'toward',
  'towards',
  'under',
  'underneath',
  'unlike',
  'until',
  'up',
  'upon',
  'versus',
  'via',
  'with',
  'within',
  'without'
];

var lowerCase = new Set([
  ...conjunctions,
  ...articles,
  ...prepositions
]);

const intended = [
  'ZEIT',
  'ZEIT Inc.',
  'CLI',
  'API',
  'HTTP',
  'HTTPS',
  'JSX',
  'DNS',
  'URL',
  'now.sh',
  'now.json',
  'CI',
  'CDN',
  'package.json',
  'GitHub',
  'GitLab',
  'CSS',
  'JS',
  'JavaScript',
  'TypeScript',
  'HTML',
  'WordPress',
  'JavaScript',
  'Next.js',
  'Node.js'
];

var specials = intended;

// Utilities



const regex = /(?:(?:(\s?(?:^|[.\(\)!?;:"-])\s*)(\w))|(\w))(\w*[â€™']*\w*)/g;

const convertToRegExp = specials => specials.map(s => [new RegExp(`\\b${s}\\b`, 'gi'), s]);

function parseMatch(match) {
  const firstCharacter = match[0];

  // test first character
  if (/\s/.test(firstCharacter)) {
    // if whitespace - trim and return
    return match.substr(1)
  }
  if (/[\(\)]/.test(firstCharacter)) {
    // if parens - this shouldn't be replaced
    return null
  }

  return match
}

var lib = (str, options = {}) => {
  str = str.toLowerCase().replace(regex, (m, lead = '', forced, lower, rest) => {
    const parsedMatch = parseMatch(m);
    if (!parsedMatch) {
      return m
    }
    if (!forced) {
      const fullLower = lower + rest;

      if (lowerCase.has(fullLower)) {
        return parsedMatch
      }
    }

    return lead + (lower || forced).toUpperCase() + rest
  });

  const customSpecials = options.special || [];
  const replace = [...specials, ...customSpecials];
  const replaceRegExp = convertToRegExp(replace);

  replaceRegExp.forEach(([pattern, s]) => {
    str = str.replace(pattern, s);
  });

  return str
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

/**
 * Returns the object type of the given payload
 *
 * @param {*} payload
 * @returns {string}
 */
function getType(payload) {
    return Object.prototype.toString.call(payload).slice(8, -1);
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is Record<string, any>}
 */
function isPlainObject(payload) {
    if (getType(payload) !== 'Object')
        return false;
    return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype;
}
/**
 * Returns whether the payload is a Symbol
 *
 * @param {*} payload
 * @returns {payload is symbol}
 */
function isSymbol(payload) {
    return getType(payload) === 'Symbol';
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __spreadArrays$1() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function assignProp(carry, key, newVal, originalObject) {
    var propType = {}.propertyIsEnumerable.call(originalObject, key)
        ? 'enumerable'
        : 'nonenumerable';
    if (propType === 'enumerable')
        carry[key] = newVal;
    if (propType === 'nonenumerable') {
        Object.defineProperty(carry, key, {
            value: newVal,
            enumerable: false,
            writable: true,
            configurable: true,
        });
    }
}
function mergeRecursively(origin, newComer, compareFn) {
    // always return newComer if its not an object
    if (!isPlainObject(newComer))
        return newComer;
    // define newObject to merge all values upon
    var newObject = {};
    if (isPlainObject(origin)) {
        var props_1 = Object.getOwnPropertyNames(origin);
        var symbols_1 = Object.getOwnPropertySymbols(origin);
        newObject = __spreadArrays$1(props_1, symbols_1).reduce(function (carry, key) {
            var targetVal = origin[key];
            if ((!isSymbol(key) && !Object.getOwnPropertyNames(newComer).includes(key)) ||
                (isSymbol(key) && !Object.getOwnPropertySymbols(newComer).includes(key))) {
                assignProp(carry, key, targetVal, origin);
            }
            return carry;
        }, {});
    }
    // newObject has all properties that newComer hasn't
    var props = Object.getOwnPropertyNames(newComer);
    var symbols = Object.getOwnPropertySymbols(newComer);
    var result = __spreadArrays$1(props, symbols).reduce(function (carry, key) {
        // re-define the origin and newComer as targetVal and newVal
        var newVal = newComer[key];
        var targetVal = isPlainObject(origin) ? origin[key] : undefined;
        // When newVal is an object do the merge recursively
        if (targetVal !== undefined && isPlainObject(newVal)) {
            newVal = mergeRecursively(targetVal, newVal, compareFn);
        }
        var propToAssign = compareFn ? compareFn(targetVal, newVal, key) : newVal;
        assignProp(carry, key, propToAssign, newComer);
        return carry;
    }, newObject);
    return result;
}
/**
 * Merge anything recursively.
 * Objects get merged, special objects (classes etc.) are re-assigned "as is".
 * Basic types overwrite objects or other basic types.
 * @param object
 * @param otherObjects
 */
function merge(object) {
    var otherObjects = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        otherObjects[_i - 1] = arguments[_i];
    }
    return otherObjects.reduce(function (result, newComer) {
        return mergeRecursively(result, newComer);
    }, object);
}

var builtInOverrides = ['PC', 'ASN', 'BGP', 'ARP', 'MTU', 'IPv4', 'IPv6', 'ASNs', 'RPKI', 'IaaS', 'DaaS', 'BaaS', 'VMware', 'DevOps', 'VDIaaS', 'AS Path', 'AS Prepend', 'AS Prepending'];

var JSON_PATTERNS = [new RegExp(/(?:\[)(.*)(?:"\])/), new RegExp(/(?:\[)(.*)(?:\])/)];
var CS_PATTERN = new RegExp(/(.+,)+/);
var SINGLE_PATTERN = new RegExp(/^[^,]+$/);
var USE_BUILT_IN_OVERRIDES = process.env.REACT_TITLE_CASE_USE_OVERRIDES;
var USER_OVERRIDES = process.env.REACT_TITLE_CASE_OVERRIDES;
function getEnvOverrides() {
  var overrides = [];

  if (typeof USER_OVERRIDES === 'string') {
    for (var _i = 0, JSON_PATTERNS_1 = JSON_PATTERNS; _i < JSON_PATTERNS_1.length; _i++) {
      var pattern = JSON_PATTERNS_1[_i];

      if (USER_OVERRIDES.match(pattern)) {
        try {
          var envArray = JSON.parse(USER_OVERRIDES);
          overrides = __spreadArrays(overrides, envArray);
        } catch (err) {
          console.warn("react-title-case tried to read overrides from environment variables, but an error occurred: " + err);
        }
      }
    }

    if (USER_OVERRIDES.match(CS_PATTERN)) {
      overrides = __spreadArrays(overrides, USER_OVERRIDES.split(','));
    } else if (USER_OVERRIDES.match(SINGLE_PATTERN)) {
      overrides = __spreadArrays(overrides, [USER_OVERRIDES]);
    }
  }

  return overrides;
}
function getEnvOptions() {
  var useBuiltIns = true;

  if (typeof USE_BUILT_IN_OVERRIDES === 'string' && USE_BUILT_IN_OVERRIDES === 'false') {
    useBuiltIns = false;
  }

  var overrides = getEnvOverrides();
  return {
    useBuiltIns: useBuiltIns,
    overrides: overrides
  };
}
var DEFAULT_OPTIONS = {
  overrides: [],
  useBuiltIns: true
};
function mergeOptions(hookOptions, ctxOptions) {
  var _a = hookOptions.overrides,
      hookOverrides = _a === void 0 ? [] : _a,
      _b = hookOptions.useBuiltIns,
      hookUseBuiltIns = _b === void 0 ? true : _b;

  var _c = ctxOptions !== null && ctxOptions !== void 0 ? ctxOptions : DEFAULT_OPTIONS,
      _d = _c.overrides,
      ctxOverrides = _d === void 0 ? [] : _d,
      _e = _c.useBuiltIns,
      ctxUseBuiltIns = _e === void 0 ? true : _e;

  var _f = getEnvOptions(),
      envUseBuiltIns = _f.useBuiltIns,
      envOverrides = _f.overrides;

  var options = merge({
    useBuiltIns: envUseBuiltIns,
    overrides: envOverrides
  }, {
    overrides: hookOverrides,
    useBuiltIns: hookUseBuiltIns
  }, {
    overrides: ctxOverrides,
    useBuiltIns: ctxUseBuiltIns
  });

  if (options.useBuiltIns) {
    options = merge(options, {
      overrides: builtInOverrides,
      useBuiltIns: true
    });
  }

  return options;
}

var TitleCaseCtx = createContext(DEFAULT_OPTIONS);
function useTitleCaseCtx() {
  return useContext(TitleCaseCtx);
}
var TitleCaseProvider = function TitleCaseProvider(props) {
  var children = props.children,
      options = __rest(props, ["children"]);

  var value = useMemo(function () {
    return options;
  }, [options]);
  return createElement(TitleCaseCtx.Provider, {
    value: value
  }, children);
};
var TitleCase = function TitleCase(props) {
  var children = props.children,
      options = __rest(props, ["children"]);

  if (typeof children !== 'string') {
    return createElement(Fragment, null, children);
  }

  return createElement(TitleCaseCtx.Consumer, null, function render(value) {
    var overrides = mergeOptions(options, value).overrides;

    function titleCase(title) {
      if (typeof title !== 'string') {
        return '';
      }

      return lib(title, {
        special: overrides
      });
    }

    return titleCase(children);
  });
};

function useTitleCase(options) {
  if (options === void 0) {
    options = DEFAULT_OPTIONS;
  }

  var ctx = useTitleCaseCtx();
  var overrides = mergeOptions(options, ctx).overrides;

  function titleCase(title) {
    if (typeof title !== 'string') {
      return '';
    }

    return lib(title, {
      special: overrides
    });
  }

  return useCallback(titleCase, [overrides]);
}

export { TitleCase, TitleCaseProvider, builtInOverrides, useTitleCase };
//# sourceMappingURL=index.js.map
